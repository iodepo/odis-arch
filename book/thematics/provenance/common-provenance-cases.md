# What is provenance?

Fundamentally, the provenance of a thing tells you where that thing came from. 

For example, real [Parmesan cheese]([url](https://en.wikipedia.org/wiki/Parmesan)) is produced in one of the provinces of Parma, Reggio Emilia, Emilia-Romagna, and parts of Mantua. That _should_ be its provenance. Thanks to the protected designations of origin (PDO) regulations in the European Union, one knows the provenance of Parmesan and Parmigiano Reggiano produced/sold in countries subject to those rules (indicated on the packaging). However, outside that regulatory environment, your Parmesan cheese can be of different or unknown provenance, with implications for its quality, authenticity, etc. Handling provenance in digital systems isn't all that different.

For datasets, documents, software, products, or anything else described by the JSON-LD/schema.org records flowing through ODIS, it's vital to indicate the provenance of the the things described. Who authored the paper? What sample was used to generate a dataset? Who or what manufactured a product? 

In this section, we provide guidelines on 1) how to express the basic provenance of a thing and 2) how to add context to that basic provenance to increase reusability, reproducibility, and add value to a digital asset.

# Basic provenance chains

The most basic provenance chain is a very short one: it should tell you where some "Thing" you're interest in originally came from. For example:
* Dataset "T363" was generated by a Temp-O-Matic Sea Surface Temperature sensor.
* Book "Guide to sampling sea salps" was published by Salps & Salps Publishing House.
* Sensor "Temp-O-Matic Sea Surface Temperature" was manufactured by "O-Matic Inc".

A (very) minimal JSON-LD/schema.org representation of the Dataset example above would need a JSON record about the Dataset itself, and another JSON record about the Action that created it.

Here's the minimal JSON-LD/schema.org about the Dataset:

```json
{
    "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Dataset",
    "@id": "https://registry.org/permanentUrlToThisJsonDoc/T363.json",
    "name": "Dummy temperature dataset",
    "identifier": "T363"
}

```

And here's the JSON-LD/schema.org about the Action that created it:

```json
{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "CreateAction",
    "@id": "https://registry.org/permanentUrlToThisJsonDoc/Creation-of-T363.json",
    "name": "Temperature measurement M363",
    "identifier": "M363",
    "actionStatus": "CompletedActionStatus",
    "instrument": "Temp-O-Matic Sea Surface Temperature sensor",
    "object": "surface seawater",
     "result": {
        "@type": "Dataset",
        "@id": "https://registry.org/permanentUrlToThisJsonDoc/T363.json"
     }
}

```

> [!NOTE]
> An Action can have many results (~ outputs) and objects (~ inputs/things the action was performed on), and can be more or less precisely scoped (e.g. we could split the measurement action above into the physical measurement and the data generation). The choice of how "granular" to be depends on each application scenario and resources available, but generally more detail is helpful for later reusability.

These two JSON records express that a dataset called "Dummy temperature dataset" with identifier "T363" was created by some completed action (with identifier M363) using a "Temp-O-Matic Sea Surface Temperatur sensor" as an instrument on some seawater. The [result](https://schema.org/result) property in the Action links the Dataset to the Action. The `@id` JSON keyword saves us some typing, as it would expand to everything in the Dataset record (assuming both records are available on the Web). 

Let's try a minimal example for a book. We could, as we did for dataset, talk about the CreateAction for the document, but since we're talking about the publisher as the "origin" of the document, we can be more compact:

```json
{
    "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Book",
    "@id": "https://registry.org/permanentUrlToThisJsonDoc",
    "name": "Guide to sampling sea salps",
    "identifier": "ISBN-13:978-1-56619-909-4",
     "publisher": {
        "@type": "Organization",
        "name": "Salps & Salps Publishing House",
        "address": "Salp street 32, Salpsville 42622, Republic of Salpia"
        }
}
```

Let's try a minimal example for the sensor, in which we use the schema.org [Product](https://schema.org/Product) type (useful for all manufactured products). As before, we could include a CreateAction and use properties from Action, but we can be more compact using the [manufacturer](https://schema.org/manufacturer) property:

```json
{
    "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Product",
    "@id": "https://registry.org/permanentUrlToThisJsonDoc",
    "name": "Temp-O-Matic Sea Surface Temperature",
    "identifier": "978-1-56619-909-4",
     "manufacturer": {
        "@type": "Organization",
        "name": "O-Matic Inc",
        "address": "O-Matic alley 3-6, Matictown 4367, Duchy of O-Matica"
        }
}
```


These most basic chains are useful, **but are rarely sufficient**. Most people (or other agents) usually need more information to confidently understand how to approach and interact with the Thing you're interested in. A more useful basic provenance chain would include:
* Information about the event (planned or unplanned) that created the Thing you're interested in, or something that it was derived from, including:
  * Who or what was involved in the event
  * What actions were performed that impacted or influenced the Thing or its precursor(s)
  * How those actions impacted that Thing or its precursor(s)
* Information about any subsequent events that changed or influenced the Thing you're interested in or its precursor(s)
* Basic contextual information about those events and the Thing you're interested in or its precursor(s). This will vary from Thing to Thing. For example:
  * The weather or other key environmental conditions at the time of sampling
  * Any known sources of error or bias

In the next sections, we'll demonstrate how to go about the above, noting how this aligns with the well-known and widely used PROV model for provenance tracking.

# The PROV model

The [PROV Model](https://dvcs.w3.org/hg/prov/raw-file/default/model/working-copy/prov-dm-issue-450.html) is a widely used model for encoding provenance information. We align the guidance here to this model as far as possible. At the time of writing, the 2013 specification of [PROV Model](http://www.w3.org/TR/2013/REC-prov-dm-20130430/) is the most current. A permalink to the latest version is available [here](http://www.w3.org/TR/prov-dm/).

If there are PROV-aligned semantics/properties that are not expressible in schema.org, then semantics/terms from the [PROV-O ontology](https://www.w3.org/TR/2013/REC-prov-o-20130430/) can be used. **However, this should be done only when absolutely necessary**, as this introduces another semantic context and can reduce interoperability (i.e. like speaking two languages in the same conversation unnecessarily).

The central PROV terms (known as [Starting Point terms](https://www.w3.org/TR/2013/REC-prov-o-20130430/#description-starting-point-terms)) are summarised in this diagram:
<img width="1775" height="1067" alt="image" src="https://github.com/user-attachments/assets/84b520d7-3d82-4bf4-a1ef-862255d81be4" />

PROV also has a set of [Expanded Terms](https://www.w3.org/TR/2013/REC-prov-o-20130430/#description-expanded-terms), which are also quite expressible in schema.org:
<img width="1729" height="957" alt="image" src="https://github.com/user-attachments/assets/0069ebd3-febf-4f4a-a582-8adc3d2c7389" />

While other extensions exist, we'll be focusing on aligning our schema.org to these sets of terms. A mapping between schema.org properties and Types to PROV terms is available in the [SSSOM](https://mapping-commons.github.io/sssom/) format, [here](https://github.com/iodepo/odis-arch/blob/master/resources/semantic-maps/schema-to-prov.sssom). 

# Core JSON-LD/schema.org patterns for expressing provenance

As expressed in the Starting Point terms of PROV model, the core of a provenance chain comprise the things we're talking about (Entities), the things that happened to them (Activities), and who or what performed these Activities (Agents). 

The key schema.org Type to use is [Action](https://schema.org/Action), which maps tightly to PROV:Activity. As we see in the example below, we can use use an Action (or its sub-Types) to express the Starting Point PROV model:

```

{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Action",
    "@id": "https://registry.org/permanentUrlToThisJsonDoc/Action-00252229.json",
    "name": "Collection of rare seashell",
    "agent": {
        "@type":"Person",
        "familyName": "Dakkar",
        "alternateName": "Captain Nemo",
        "honorificPrefix": "Prince"
    },
    "identifier": "nautilus-sampling-event:00252229",
    "actionStatus": "CompletedActionStatus",
    "instrument": "Nautilus sampling array",
    "object": "Intact Fulton's cowrie (Cypraea fultoni) shell",
    "result": "nautilus-sample:00713668",
    "startTime": "1848-11-17T14:42:10Z",
    "endTime": "1848-11-17T14:46:13Z"
}

```

This minimal code expresses a schema:Action (prov:Activity) performed by a schema:agent (prov:Agent) which used (prov:used) the "Nautilus sampling array" to collect an intact Fulton's cowrie shell (schema:object), with a schema:result of a sample in the Nautilus extensive collection (i.e. the result prov:wasGeneratedBy the Action). The start and end time of the action are also recorded.

> [!NOTE]
> Naturally, one can and should use schema.org Types as values for each property (like `instrument`, `object` and `result`) to add more metadata or link to full records of these entities. The examples here are very terse.

Next, let's add another action to describe processing that sampled seashell for archiving in the Nautilus' specimen collection:

```

{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Action",
    "@id": "https://registry.org/permanentUrlToThisJsonDoc/Action-00252229.json",
    "name": "Incorporation of Nautilus Sample 00713668 into the Nautilus Specimen Archive",
    "agent": {
        "@type":"Person",
        "familyName": "Dakkar",
        "alternateName": "Captain Nemo",
        "honorificPrefix": "Prince"
    },
    "participant": {
        "@type":"Person",
        "givenName": "Pierre",
        "familyName": "Aronnax",
        "honorificPrefix": "Professor"
    },
    "identifier": "nautilus-archiving-event:00592754",
    "actionStatus": "CompletedActionStatus",
    "instrument": [
        "sonication cleaning bath",
        "sealant vapour deposition chamber",
        "Nautilus thinking machine"
    ],
    "object": "nautilus-sample:00713668",
    "result": "nautilus-collection-item:00515643",
    "startTime": "1848-11-17T14:42:10Z",
    "endTime": "1848-11-17T14:46:13Z"
}

```

> [!IMPORTANT]
> Pay close attention to the way that the results and objects of an Action build a provenance chain: In the example above, we treat the output (result) of the previous Action as the input (object) of the next Action - this is how we connect the links of a provenance chain. Unambiguous identifiers for each element described and persistent URLs for each JSON-LD file are extremely valuable in making this chain unambiguous.

The JSON-LD/schema.org example above expresses that Captain Nemo, with the help of Professor Aronnax, used a sonication cleaning bath, a sealant vapour deposition chamber, and the Nautilus' computer to take the sample acquired in the previous Action, and archive it in the Nautilus' collection. 

The examples above describe the provenance of physical objects. Let's create another Action to express how a Dataset was created from the entity, once it was sampled. As above, we'll use the `object` and `result` properties to connect Actions to each other, as well as their inputs and outputs:

```

{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Action",
    "@id": "https://registry.org/permanentUrlToThisJsonDoc/Action-00252229.json",
    "name": "3D scanning of nautilus-collection-item:00515643",
    "agent": {
        "@type":"Person",
        "givenName": "Pierre",
        "familyName": "Aronnax",
        "honorificPrefix": "Professor"
    },
    "identifier": "nautilus-scanning-event:02552891",
    "actionStatus": "CompletedActionStatus",
    "instrument": "Nautilus 3D scanning chamber",
    "object": "nautilus-collection-item:00515643",
    "result": {
        "@type": "Dataset",
        "identifer": "nautilus-3D-scan:02545642",
        "name": "3D Scane of Nautilus Collection Item 00515643"
    },
    "startTime": "1848-11-17T15:39:04Z",
    "endTime": "1848-11-17T15:50:19Z"
}

```

This record states (among other things) that 3D Scanning Action was performed upon the Collection Item generated in the previous Action. The result of that Action is a Dataset with a unique and persistent identifier. As we saw in the first set of examples, one can have a separate JSON record for the Dataset, rather than embedding it in an Action record. In that case, it would need an `@id` to identify it such that it can be found and correctly placed as the value of `result`.  


## The main Thing and its origin story

Start with the beginning and end/current point 

## Events 

Using additionType for Events

For large-scale planned actions or for unplanned events (natural formation)

recordedAt

Relationship between Events and Actions by space-time overlap and sharing of participants 

## The Actions

An Action can be many things: a sampling event, and observation event, a modelling run, an analytical routine, 
Using additionalType for Actions


## Breaking down the Actions with HowTos

Once you have an action like "sampling of deep-sea sediment"
Using additionalTypes with Actions.

SOSA actuation and changing parameters during an experiment

## Linking to Datasets and other Creative Works

Note on variable-by-variable provenance, need for variable by variable `@id`s 

# Enriching a provenance chain with context

## Using additionalTypes

## Filling out properties

## Using additionalProperties

The core chain and the decorations 

Each domain and discipline will have different requirements, but the general principle is that the metadata contextualising the provenance chain should allow understanding and reproducibility.


# Examples of common provenance patterns

Some aligned to CDIF cases 


## Sample Collection 

Both material and statistical samples, including statistical sampling from an existing dataset as well as the creation of a sample dataset from measuring material things

## Sample processing / analysis

## Observation

## Model / analytical output

With CreativeWork as source

## Data production

The start of the isBasedOn chain

## Data harvest

## Data processing
Including subsetting and reformatting / new semantic markup of data

## Data validation

## Data Analysis


## Claims / assertions
## Quality and quality control
of data or other assets

Adding quality control actions and their outcomes as Claims 

# Advanced provenance 

## Highly granular provenance 

### Variable-level provenance 
variableMeasured - individual variable-by-variable provenance 

### breaking up Datasets and other creative works

Other CDIF cases to capture
Experiment
Hypothesis
Sample (material and statistical samples)
Method
Configuration
Instrument
* use sosa for the additionalType and then something like NERC SKOS for keywords?

```json
{
     "@context": {
        "@vocab": "https://schema.org/"
 },
            "@type": "Product",
            "@id": "https://urlToThisJson.org/sea-bird-SBE.json/",
            "name": "SeaTemp 5000 Sensor",
            "description": "High precision sea surface temperature sensor.",
            "manufacturer": {
              "@type": "Organization",
              "name": "SensorCorp"
            },
        "model": {
            "@type": "ProductModel",
            "identifer": "http://vocab.nerc.ac.uk/collection/L22/current/TOOL0022/",
            "name": "Sea-Bird SBE 37 MicroCat IM-CT with optional pressure (submersible) CTD sensor series"
        },
            "serialNumber": "SN-998877",
            "additionalProperty": [
              {
                "@type": "PropertyValue",
                "name": "accuracy",
                "value": "+/- 0.01 K"
              },
              {
                "@type": "PropertyValue",
                "name": "precision",
                "value": "0.005 K"
              }
            ]
            }
```


## Notes on Agents

Human, software, instrument / machine agent and their roles 

 
