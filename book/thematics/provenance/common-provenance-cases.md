# What is provenance?

Fundamentally, the provenance of a thing tells you where that thing came from. 

For example, real [Parmesan cheese]([url](https://en.wikipedia.org/wiki/Parmesan)) is produced in one of the provinces of Parma, Reggio Emilia, Emilia-Romagna, and parts of Mantua. That _should_ be its provenance. Thanks to the protected designations of origin (PDO) regulations in the European Union, one knows the provenance of Parmesan and Parmigiano Reggiano produced/sold in countries subject to those rules (indicated on the packaging). However, outside that regulatory environment, your Parmesan cheese can be of different or unknown provenance, with implications for its quality, authenticity, etc. Handling provenance in digital systems isn't all that different.

For datasets, documents, software, products, or anything else described by the JSON-LD/schema.org records flowing through ODIS, it's vital to indicate the provenance of the the things described. Who authored the paper? What sample was used to generate a dataset? Who or what manufactured a product? 

In this section, we provide guidelines on 1) how to express the basic provenance of a thing and 2) how to add context to that basic provenance to increase reusability, reproducibility, and add value to a digital asset.

# Why should you care about provenance?

Just like in the example above, unless you have information about a thing's origin and what happened to it before you encountered it, you can't really verify its qualities or claims about it. Is it authentic? Who can you contact to verify any quality flags on it? How was it modified along its lifetime? Is it "fit for (your) purpose"? 

Without a clear provenance chain, (re)using data can be perilous. In science, data of unknown provenance can lead to inaccurate or corrupted results. In advising decision makers, policy developers, or the public, they can be misleading and compromise trust. As the volume and variety of data flowing through organisations continues to grow, and data products and services weave together ever more datasets and streams, it is no longer viable to contact individuals or organisations to explain the origin and lifecycle of data: this information must be linked to or bundled with subject data.


# Basic provenance chains

The most basic provenance chain is a very short one: it should tell you where some "Thing" you're interest in originally came from. For example:
* Dataset "T363" was generated by a Temp-O-Matic Sea Surface Temperature sensor.
* Book "Guide to sampling sea salps" was published by Salps & Salps Publishing House and authored by S.R. Salpian.
* Sensor "Temp-O-Matic Sea Surface Temperature" was manufactured by "O-Matic Inc".

A (very) minimal JSON-LD/schema.org representation of the Dataset example above would need a JSON record about the Dataset itself, and another JSON record about the Action that created it.

Here's the minimal JSON-LD/schema.org about the Dataset:

```json
{
    "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Dataset",
    "@id": "https://myOrganisation.example/identifiers/T363.json",
    "name": "Dummy temperature dataset",
    "identifier": "T363"
}

```

And here's the JSON-LD/schema.org about the Action that created it:

```json
{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "CreateAction",
    "name": "Temperature measurement M363",
    "identifier": "M363",
    "actionStatus": "CompletedActionStatus",
    "instrument": "Temp-O-Matic Sea Surface Temperature sensor",
    "object": "surface seawater",
     "result": {
        "@type": "Dataset",
        "@id": "https://myOrganisation.example/identifiers/T363.json"
     }
}

```

> [!NOTE]
> An Action can have many results (~ outputs) and objects (~ inputs/things the action was performed on), and can be more or less precisely scoped (e.g. we could split the measurement action above into the physical measurement and the data generation). The choice of how "granular" to be depends on each application scenario and resources available, but generally more detail is helpful for later reusability.

These two JSON records express that a dataset called "Dummy temperature dataset" with identifier "T363" was created by some completed action (with identifier M363) using a "Temp-O-Matic Sea Surface Temperatur sensor" as an instrument on some seawater. The [result](https://schema.org/result) property in the Action links the Dataset to the Action. The `@id` JSON keyword saves us some typing, as it would expand to everything in the Dataset record (assuming both records are available on the Web or similar network). 

Let's try a minimal example for a book. We could, as we did for dataset, create a JSON-LD record/object about the CreateAction for the book and then link it to a JSON-LD record/object about the book itself, but since we're talking about a publisher and author as the "origin" of the document, we can be more compact using some schema.org properties:

```json
{
    "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Book",
    "name": "Guide to sampling sea salps",
    "identifier": "ISBN-13:978-1-56619-909-4",
    "author": "S.R. Salpian",
     "publisher": {
        "@type": "Organization",
        "name": "Salps & Salps Publishing House",
        "address": "Salp street 32, Salpsville 42622, Republic of Salpia"
        }
}
```

Let's try a minimal example for the sensor, in which we use the schema.org [Product](https://schema.org/Product) type (useful for all manufactured products). As before, we could include a CreateAction and use properties from Action, but we can be more compact using the [manufacturer](https://schema.org/manufacturer) property:

```json
{
    "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Product",
    "name": "Temp-O-Matic Sea Surface Temperature",
    "identifier": "978-1-56619-909-4",
     "manufacturer": {
        "@type": "Organization",
        "name": "O-Matic Inc",
        "address": "O-Matic alley 3-6, Matictown 4367, Duchy of O-Matica"
        }
}
```


These most basic chains are useful, **but are rarely sufficient**. Most people (or other agents) usually need more information to confidently understand how to approach and interact with the Thing you're interested in. A more useful basic provenance chain would include:
* Information about the event (planned or unplanned) that created the Thing you're interested in, or something that it was derived from, including:
  * Who or what was involved in the event
  * What actions were performed that impacted or influenced the Thing or its precursor(s)
  * How those actions impacted that Thing or its precursor(s)
* Information about any subsequent events that changed or influenced the Thing you're interested in or its precursor(s)
* Basic contextual information about those events and the Thing you're interested in or its precursor(s). This will vary from Thing to Thing. For example:
  * The weather or other key environmental conditions at the time of sampling
  * Any known sources of error or bias

In the next sections, we'll demonstrate how to go about the above, noting how this aligns with the well-known and widely used PROV model for provenance tracking.

# The PROV model

> [!NOTE]
> For developers and digital practitioners, a mapping (unofficial, created for this guidance) between schema.org properties and Types to PROV terms is available in the [SSSOM](https://mapping-commons.github.io/sssom/) format, [here](https://github.com/iodepo/odis-arch/blob/master/resources/semantic-maps/schema-to-prov.sssom). 


The [PROV Model](https://dvcs.w3.org/hg/prov/raw-file/default/model/working-copy/prov-dm-issue-450.html) is a widely used model for encoding provenance information. We align the guidance here to this model as far as possible. At the time of writing, the 2013 specification of [PROV Model](http://www.w3.org/TR/2013/REC-prov-dm-20130430/) is the most current. A permalink to the latest version is available [here](http://www.w3.org/TR/prov-dm/).

> [!WARNING]
> If there are PROV-aligned semantics/properties that are not expressible in schema.org, then semantics/terms from the [PROV-O ontology](https://www.w3.org/TR/2013/REC-prov-o-20130430/) can be used. **However, this should be done only when absolutely necessary**, as this introduces another semantic context and can reduce interoperability (i.e. like speaking two languages in the same conversation unnecessarily).
>
> Many PROV properties/relations like wasRevisionOf can/should be expressed by dedicated Actions in schema.org (e.g. a Revision Action), where the action can be described fully rather than adding the PROV-O property as a less informative short-cut.

The central PROV terms (known as [Starting Point terms](https://www.w3.org/TR/2013/REC-prov-o-20130430/#description-starting-point-terms)) are summarised in this diagram:
<img width="1775" height="1067" alt="image" src="https://github.com/user-attachments/assets/84b520d7-3d82-4bf4-a1ef-862255d81be4" />

PROV also has a set of [Expanded Terms](https://www.w3.org/TR/2013/REC-prov-o-20130430/#description-expanded-terms), which are also quite expressible in schema.org:
<img width="1729" height="957" alt="image" src="https://github.com/user-attachments/assets/0069ebd3-febf-4f4a-a582-8adc3d2c7389" />

While other extensions exist, we'll be focusing on aligning our schema.org to these sets of terms. 
# Core JSON-LD/schema.org patterns for expressing provenance

As expressed in the Starting Point terms of PROV model, the core of a provenance chain comprise the things we're talking about (Entities), the things that happened to them (Activities), and who or what performed these Activities (Agents). 

The key schema.org Type to use is [Action](https://schema.org/Action), which maps tightly to PROV:Activity. As we see in the example below, we can use use an Action (or its sub-Types) to express the Starting Point PROV model:

First we'll show a basic (but less powerful and less reusable) example where properties are not typed. Instead, we'll jsut use 'literal' values to show the basic case.

```json
{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Action",
    "name": "Collection of rare seashell by the Nautilus sampling array",
    "agent": "Captain Nemo",
    "identifier": "nautilus-sampling-event:00252229",
    "actionStatus": "CompletedActionStatus",
    "location": "Pollux Tablemount",
    "instrument": "Nautilus sampling array",
    "object": "Intact Fulton's cowrie (Cypraea fultoni) shell",
    "result": "nautilus-sample:00713668",
    "startTime": "1848-11-17T14:42:10Z",
    "endTime": "1848-11-17T14:46:13Z"
}

```

Now, let's replace some of those literal values with typed JSON-LD objects. This allows us to do many more things with them, including 1) referencing and reusing their parts via `@id` values (like expanding a variable) and 2) adding richer, structured information about the things the values represent. 

> [!NOTE]
> We'll stick to using JSON objects (the things in braces / curly brackets), shown in the next example, for key entities used often in the rest of this document. When you see just the `@id` of an object somewhere, that means that the entire object it references (including all the properties) will be placed there.
>
> The values we're using for `@id`s on this page often contain some semantics (i.e. the world "sample" appears in an `@id` for a sample). This is only to ease reading: in general, identifiers should not contain information themselves, but point to something that does. For example, a meaningless identifier like "25321ke561" is generally better than one like "sample-15-Monday". There are many reasons for this, including the occasional need to rename or correct (meta)data that overlaps with the identifier value (which should never be changed once released).
>
> Note that the expansion of `@id`s **relies on the files they reference being available on a network like the Web**. If they cannot be found, they cannot be expanded, once again underscoring the importance of persistent identifiers and URLs, as well as long-term hosting and access solutions. 


```json
{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Action",
    "@id": "https://nautilus.verne/identifiers/Action-00252229.json",
    "name": "Collection of rare seashell by the Nautilus sampling array",
    "agent": {
        "@id": "https://nautilus.verne/identifiers/Person-00000001.json",
        "@type":"Person",
        "familyName": "Dakkar",
        "alternateName": "Captain Nemo",
        "honorificPrefix": "Prince"
    },
    "identifier": "nautilus-sampling-event:00252229",
    "actionStatus": "CompletedActionStatus",
    "location": {
        "@type": "Place",
        "@id": "https://nautilus.verne/identifiers/location-00075663.json",
        "name": "Pollux Tablemount",
        "latitude": "25.75",
        "longitude": "147.8333"
    },
    "instrument": {
        "@id": "https://nautilus.verne/identifiers/nautilus-equipment-00002634.json",
        "@type": "Product",
        "name": "Nautilus sampling array",
        "identifier": "nautilus-equipment-00002634"
    },
    "object": "Intact Fulton's cowrie (Cypraea fultoni) shell",
    "result": {
        "@id": "https://nautilus.verne/identifiers/nautilus-sample-00713668.json",
        "@type": "Product",
        "name": "Sample 00713668",
        "identifier": "nautilus-sample:00713668",
        "material": ["calcium carbonate", "biomass"]
    },
    "startTime": "1848-11-17T14:42:10Z",
    "endTime": "1848-11-17T14:46:13Z"
}

```

This minimal example expresses a schema:Action (prov:Activity) performed by a schema:agent (prov:Agent) which used (prov:used) the "Nautilus sampling array" to collect an intact Fulton's cowrie shell (schema:object) at a specific place (prov:atLocation/Location) and time (prov:generatedAtTime), with a schema:result of a sample in the Nautilus extensive collection (i.e. the result prov:wasGeneratedBy the Action). The start and end time of the action are also recorded.

> [!NOTE]
> Note that we're using the schema.org Type `Product` to type the sample object (i.e. a product of a sampling action). The `Product` Type offers many useful properties for samples, including those describing its size, weight, composition, and relation to other samples typed as products. See the section on using additionalTypes, below, for guidance on how to add more specific types like [material sample](http://purl.obolibrary.org/obo/OBI_0000747), an OWL class from the Ontology for Biomedical Investigations.


Next, let's add another action to describe processing that sampled seashell for archiving in the Nautilus' specimen collection. Remember that we'll just use the `@id`s of JSON objects we've described above, to save space and focus on new material:

```json
{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Action",
    "@id": "https://nautilus.verne/identifiers/Action-00252230.json",
    "name": "Incorporation of Nautilus Sample 00713668 into the Nautilus Specimen Archive",
    "agent": {
        "@id": "https://nautilus.verne/identifiers/Person-00000001.json"
    },
    "participant": {
        "@id": "https://nautilus.verne/identifiers/Person-00000562.json",
        "@type":"Person",
        "givenName": "Pierre",
        "familyName": "Aronnax",
        "honorificPrefix": "Professor"
    },
    "identifier": "nautilus-archiving-event:00592754",
    "actionStatus": "CompletedActionStatus",
    "instrument": [
        "sonication cleaning bath",
        "sealant vapour deposition chamber",
        "Nautilus thinking machine"
    ],
    "object": {  "@id": "https://nautilus.verne/identifiers/nautilus-sample-00713668.json" },
    "result": {
        "@type": "Product",
        "@id": "https://nautilus.verne/identifiers/nautilus-collection-item-00515643.json",
        "identifier": "nautilus-collection-item:00515643",
        "name": "An prepared specimen of an intact Fulton's cowrie (Cypraea fultoni) shell"
        },
    "startTime": "1848-11-17T14:42:10Z",
    "endTime": "1848-11-17T14:46:13Z"
}

```

> [!IMPORTANT]
> Pay close attention to the way that the results and objects of an Action build a provenance chain: In the example above, we treat the output (result) of the previous Action as the input (object) of the next Action - this is how we connect the links of a provenance chain. Unambiguous identifiers for each element described and persistent URLs for each JSON-LD file are extremely valuable in making this chain unambiguous.

The JSON-LD/schema.org example above expresses that Captain Nemo, with the help of Professor Aronnax, used a sonication cleaning bath, a sealant vapour deposition chamber, and the Nautilus' computer to take the sample acquired in the previous Action, and archive it in the Nautilus' collection. 

The examples above describe the provenance of physical objects. Let's create another Action to express how a Dataset was created from the entity, once it was sampled. As above, we'll use the `object` and `result` properties to connect Actions to each other, as well as their inputs and outputs:

```json
{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Action",
    "@id": "https://nautilus.verne/identifiers/Action-00252231.json",
    "name": "3D scanning of nautilus-collection-item:00515643",
    "agent": { "@id": "https://nautilus.verne/identifiers/Person-00000562.json" },
    "identifier": "nautilus-scanning-event:02552891",
    "actionStatus": "CompletedActionStatus",
    "instrument": "Nautilus 3D scanning chamber",
    "object": { "@id": "https://nautilus.verne/identifiers/nautilus-collection-item-00515643.json" },
    "result": {
        "@type": "Dataset",
        "@id": "https://nautilus.verne/identifiers/Dataset-015481461",
        "identifier": "nautilus-3D-scan:02545642",
        "name": "3D Scan of Nautilus Collection Item 00515643",
        "about": { "@id": "https://nautilus.verne/identifiers/nautilus-collection-item-00515643.json" }
    },
    "startTime": "1848-11-17T15:39:04Z",
    "endTime": "1848-11-17T15:50:19Z"
}

```

> [!NOTE]
> Pay special attention on how we link from the Action to the Dataset (via `result`) and from the Dataset back to the Action (using `about`). This is useful in case these objects are hosted separately: it wouldn't matter which one you found, you would be able to find the other thanks to the reciprocal linking.

This record states (among other things) that 3D Scanning Action was performed upon the Collection Item generated in the previous Action. The result of that Action is a Dataset with a unique and persistent identifier, which is about the Collection Item. As we saw in the first set of examples, one can have a separate JSON record for the Dataset, rather than embedding it in an Action record. In that case, it would need an `@id` to identify it such that it can be found and correctly placed as the value of `result`.  

## Breaking down the Actions with HowTos

Ideally, a provenance record wouldn't just note that an Action occurred, but also how it occurred (i.e. what exact steps were taken to perform that Action). This information is very valuable for reproducibility and clear understanding of how things like datasets or samples came to be in the state they are.

The schema:`Action` Type offers a property called `actionProcess` where one can add a `HowTo` Type to log the steps taken to perform an Action. As with any Type, one can host these `HowTo`s and even their `HowToStep`s as stand-alone records with their own identifiers and `@id` values, to make reuse easier. To keep things more readable here, we'll skip this step. 

Let's examine a case expanding the 3D-scanning Action, above. Look for the `actionProcess` value, and :

> [!NOTE]
> Arrays in JSON - like the array of steps below - preserve their order, and the position of an object in an array is its position in that order.

```json
{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Action",
    "@id": "https://nautilus.verne/identifiers/Action-00252231.json",
    "name": "3D scanning of nautilus-collection-item:00515643",
    "agent": { "@id": "https://nautilus.verne/identifiers/Person-00000562.json" },
    "identifier": "nautilus-scanning-event:02552891",
    "actionStatus": "CompletedActionStatus",
    "instrument": "Nautilus 3D scanning chamber",
    "object": "nautilus-collection-item:00515643",
    "result": {
        "@id": "https://nautilus.verne/identifiers/Dataset-015481461",
        "@type": "Dataset",
        "identifier": "nautilus-3D-scan:02545642",
        "name": "3D Scan of Nautilus Collection Item 00515643",
        "about": "nautilus-collection-item:00515643"
    },
    "startTime": "1848-11-17T15:39:04Z",
    "endTime": "1848-11-17T15:50:19Z",
    "actionProcess": {
       	"@id":"https://nautilus.verne/identifiers/Protocol-00006215",
      	"@type": "HowTo",
        "name": "How to 3D scan a seashell with the Nautilus 3D scanning chamber",
        "estimatedCost": "20 Pounds Sterling and 40 shillings",
        "performTime": "T2H30M",
        "prepTime": "T30M",
        "supply": [
            "ambergris",
            "blank Amethyst data slate"
        ],
        "tool": [
            "asbestos gloves",
            "kelp-leather apron",
            "topaz protective goggles",
            "soda-lime gas mask"
        ],
        "yield": "Amethyst data slate with 3D scan data",
        "step": [
            {
                       	"@id":"https://nautilus.verne/identifiers/Protocol-step-00015209",
              	"@type": "HowToStep",
                "name": "Initialisation of the Nautilus 3D scanning chamber",
                "description": "Add three grains of ambergris to the device's brass thurible",
                "subjectOf": {
                  "@id": "https://wwww.nautilus.verne/identifiers/Video-00002167",
                    "@type": "VideoObject",
                    "name": "Videographic guide to the initialisation of the Nautilus 3D scanning chamber",
                    "contentUrl": "https://nautilus.verne/video-archive/26623.video"
                    }
            },
             {
                "@id":"https://nautilus.verne/identifiers/Protocol-step-00015210",
                "@type": "HowToStep",
                "name": "Sample loading",
                "description": "Place the object to be scanned in the copper casket ornamented with krakens at the centre of the chamber"
            },
            {
                "@id":"https://nautilus.verne/identifiers/Protocol-step-00015211",
              "@type": "HowToStep",
                "name": "Configuration of the scanning process",
                "description": "Approach the luminous display panel bordered by red coral. Speak clearly and deferentially to explain how the scanning should proceed. The Nautilus difference engine will configure the chamber to account for your preferences. Should there be uncertainties, the difference engine shall ask you for further clarification."
            },
            {
                "@id":"https://nautilus.verne/identifiers/Protocol-step-00015212",
                "@type": "HowToStep",
                "name": "Shelter or depart",
                "description": "Shelter behind at least 4 inches of cinnabar-coated lead during the operation of the machine. Alternatively, leave the scanning laboratory entirely - the scanning requires no supervision."
            },
            {
                "@id":"https://nautilus.verne/identifiers/Protocol-step-00015213",
              "@type": "HowToStep",
                "name": "Scanning",
                "description": "The chamber will scan the sample by eldritch means. Scanning is complete when the copper casket ornamented with Krakens opens."
            },
                        {
                "@id":"https://nautilus.verne/identifiers/Protocol-step-00015214",
                          "@type": "HowToStep",
                "name": "Sample retrieval",
                "description": "Retrieve the sample from the copper casket ornamented with Krakens opens. Return to secure archiving or storage as needed."
            },
            {
              "@id":"https://nautilus.verne/identifiers/Protocol-step-00015215",  
              "@type": "HowToStep",
                "name": "Data slate retrieval",
                "description": "Approach the alcove ornamented with hippocampi in rampant pose. An amethyst data slate will emerge. Wait for it to cool and retrieve it. Your 3D scan is examinable with the Nautilus holographicum."
            }
            
        ]
    }
}
```

One can add as many `HowToStep`s as are needed, and use them to link out to any other documentation, multimedia, or other resources that can help someone perform a method. You'll notice in the first `HowToStep` above, a link to a `VideoObject` was included as an example. You can use the `subjectOf` property on any `HowToStep` to link to one or more supporting resources. Also note, since we used `@id`s for each `HowToStep`, we can reuse these individually, in other protocols/methods or other assets.

## Where to start and end a provenance chain

### Starting a provenance chain
A common concern is where to _start_ a provenance chain. There's no hard and fast answer to this, but - generally - one would start the main provenance chain where the first intentional action was taken by an agent upon some entity/Thing that either is the Thing one is interested in, or was an important precursor of that Thing.

In the examples above, let's say our main entity of interest was the Dataset (nautilus-3D-scan:02545642). Capturing the sampling action and the archiving actions that preceded the scanning action would be very helpful in understanding where the 3D scan dataset came from and what the data is about, along with providing information to explain any bias/errors such as artifacts introduced by the sealing and cleaning instruments used during archiving. Thus, the provenance chain of the dataset would start with the sampling of the shell the dataset is about.

Events or processes that _preceded_ the first intentional event are also important to contextualise the intentional actions along a provenance chain. Adding a few of these to a provenance chain can be very important to help communicate _why_ the first intentional action was taken in the first place. For more on this, see the section, below, on "Enriching a provenance chain with context".

### Ending a provenance chain

The most obvious place to end a provenance chain is at the current state of a Thing. However, one could also add some metadata to express what some agent should or could do to the Thing in the future, or what is currently happening to the Thing.

The schema.org `potentialAction` property can be used on any `Thing` to express what _could_ be done to that `Thing` in the future or what is currently happening to that thing. Here's a terse example: 

```json
{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Thing",
    "@id": "https://nautilus.verne/identifiers/Action-00252230.json",
    "name": "Incorporation of Nautilus Sample 00713668 into the Nautilus Specimen Archive",
    "identifier": "nautilus-collection-item:00515643",
    "potentialAction": [
        {
            "@id": "https://nautilus.verne/identifiers/Action-00252231.json",
            "@type": "Action",
            "name": "Transfer to the Laboratory at Centre of the Earth",
            "actionStatus": "PotentialActionStatus",
            "description": "The LatCotE possesses advanced X-ray technology, which may be used to further investigate the cause of the mass die off recorded in ecosystem-event:0226554433"
        },
        {
            "@id": "https://nautilus.verne/identifiers/Action-00252232.json",
            "@type": "Action",
            "name": "Disinfection by periodic UV pulses",
            "actionStatus": "ActiveActionStatus",
            "description": "Specimen nautilus-collection-item:0051564 is subject to disinfection by UV from pulsed-xenon lamps with a peak emission near 230 nm at 8,000 Î¼J/cm^2",
            "url": "https://nautilus.verne/methods/26263.txt"
        }
    ]
    
}

```

In this example, the two actions described are the potential tranfer of the specimen to another laboratory for a specific test, and an ongoing action of periodic disinfection of the sample by periodic pulses of UV light (with a URL to a full method). This is an elegant way to end a provenance chain, which can help users understand what's happening to a Thing at the moment, and what people thing should happen to it. The latter can be used for matchmaking (i.e. matching agents with specified capacities to the things they can work on).

## Events 

### Representing an event

Sometimes, unplanned processes that don't or may not have an agent (i.e. sometihng with agency, will, or volition) can affect the provenance of a prov:Entity or schema:Thing. For example, consider the impact of a natural or unplanned event like a cyclone or tsunami, equipment malfunctioning, or the degradation of a sample over time.

To help express these, schema.org offers an [Event](https://schema.org/Event) Type. Despite its original purpose to describe things like rock concerts or art exhibitions, this type can be used along a chain of Actions to record important occurrences that influenced the Thing you're interested in. Let's set up a basic example to describe an Event that made Captain Nemo decide to sample that seashell:

```json
{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Event",
    "@id": "https://nautilus.verne/identifiers/Event-01259994.json",
    "name": "Mass gathering and die off of Cypraea fultoni population",
    "identifier": "ecosystem-event:02265544332",
    "location": { "@id": "https://nautilus.verne/identifiers/location-00075663.json" },
    "startDate": "1848-09-17",
    "endDate": "1848-18-17"
}
```

Note that the start date and end date of this Event contain the sampling event, and the location of the die off and the sampling event are the same. This allows matching these records with a spatial or temporal query, and the contextualisation of the Action with the Event.

One could be even more explicit, using a "sub-Event" and the `recordedIn` property to state that the 3D scan dataset records a part of this Event where the biomass of an individual Cypraea fultoni organism was deposited on the seafloor:

```json
{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Event",
    "@id": "https://nautilus.verne/identifiers/Event-01259994.json",
    "name": "Mass gathering and die off of Cypraea fultoni population",
    "identifier": "ecosystem-event:02265544332",
    "location": {  "@id": "https://nautilus.verne/identifiers/location-00075663.json"
    },
    "startDate": "1848-09-17",
    "endDate": "1848-18-17",
    "subEvent": {
        "@type": "Event",
        "@id": "https://nautilus.verne/identifiers/Event-01259998.json",
        "name": "Posthumous deposition of biomass of Cypraea fultoni individual obtained as nautilus-sample:00713668",
        "identifier": "ecosystem-event:02265544345",
        "recordedIn": "nautilus-3D-scan:02545642"
    }
}
```

This rendition links the identifiers of the dataset to the Events more explicitly, using `recordedIn` to link the dataset to the event, strengthening the links between these records with unambiguous context. That being said, the `recordedIn` property is quite "fuzzy", and doesn't precisely describe the relationship of most datasets

Unfortunately, schema.org doesn't seem to have a compact way of linking Actions to Events (e.g. like an "embeddedIn" or a process equivalent of "partOf"). Please see the "Using additional properties" section, below, for some possible approaches.

### Embedding Actions within Events

There's a clever way to embed an Action in an Event (i.e. that an Action occurred within an Event) by double-typing an object under `subEvent`. By multi-typing a JSON-LD object, one can use properties from both types. See an example below:

> [!WARNING]
> When multi-typing an object, **it's important that the Types used makes sense together.** Events and Actions are compatible (conceptually, an Event can also be an Action), but one wouldn't type something as both an Action and a Person, or a Vehicle and a Project.
> 
> **Please don't add a Type to an object just because it allows you to use a property from another Type that you think is convenient.** The types **must** make sense together.

```json
{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Event",
    "@id": "https://nautilus.verne/identifiers/Event-01259994.json",
    "name": "Mass gathering and die off of Cypraea fultoni population",
    "identifier": "ecosystem-event:02265544332",
    "location": {
       "@id": "https://nautilus.verne/identifiers/location-00075663.json"
    },
    "startDate": "1848-09-17",
    "endDate": "1848-18-17",
    "subEvent": {
        "@type": ["Event", "Action"],
    "@id": "https://nautilus.verne/identifiers/Action-00252229.json",
    "name": "Collection of rare seashell by the Nautilus sampling array",
    "agent": {
        "@id": "https://nautilus.verne/identifiers/Person-00000001.json",
        "@type":"Person",
        "familyName": "Dakkar",
        "alternateName": "Captain Nemo",
        "honorificPrefix": "Prince"
    },
    "identifier": "nautilus-sampling-event:00252229",
    "actionStatus": "CompletedActionStatus"
    }
}
```


# Enriching a provenance chain with context

The basic provenance chains we've seen provide the core "trace" of a Thing's provenance. Naturally, there's a lot more information that most people would like about the links in that chain. 

We've already "decorated" the provenance chains described above with more information (e.g. information on agents), but there's likely much more to say. Below, we'll provide some general suggestions on how to enrich your provenance chain.



## Filling out properties

The easiest way to add rich context to a provenance chain in schema.org is simply to fill in as many properties on the Types you use. Ideally, those properties will be filled in by dedicated objects (i.e. Types, like `@Person` above) rather than just text, so more structured metadata is available to improve discovery, description, and (re)use.

For example:

```json
  "agent": {
        "@id": "https://nautilus.verne/identifiers/Person-00000001.json",
        "@type":"Person",
        "familyName": "Dakkar",
        "alternateName": "Captain Nemo",
        "honorificPrefix": "Prince"
    }
```

is much better than:


```json
  "agent": "Captain Nemo"
```

Of course, if you had a stand-alone JSON-LD object or file with a resolvable `@id` to represent Captain Nemo, one could also do:

```json
   "agent": { "@id": "https://nautilus.verne/identifiers/Person-00000001.json" }
```

That would point to:
```json
  "agent": {
        "@id": "https://nautilus.verne/identifiers/Person-00000001.json",
        "@type":"Person",
        "familyName": "Dakkar",
        "alternateName": "Captain Nemo",
        "honorificPrefix": "Prince"
    }
```



## Adding Roles

Often, one would want to explicitly declare the roles of things like agents, especially if there are many participating in an Action. The Schema.org [Role](https://schema.org/Role) Type allows us to express roles within properties like (but certainly not limited to) `agent` and `instrument`:

```json

{
  "@context": {
    "@vocab": "https://schema.org/"
  },
  "@type": "Action",
  "@id": "https://nautilus.verne/identifiers/Action-00252231.json",
  "name": "3D scanning of nautilus-collection-item:00515643",
  "agent": {
    "@type": "Role",
    "agent": {
        "@id": "https://nautilus.verne/identifiers/Person-00000562.json",
        "@type": "Person",
        "givenName": "Pierre",
        "familyName": "Aronnax",
        "honorificPrefix": "Professor"
    },
    "startDate": "1848-01",
    "endDate": "1849-12",
    "roleName": "Nautilus guest scientist"
  },
  "identifier": "nautilus-scanning-event:02552891",
  "actionStatus": "CompletedActionStatus",
  "instrument": {
    "@type": "Role",
    "instrument": {
      "@type": "Product",
      "name": "Nautilus 3D scanning chamber"
    },
    "startDate": "1848-11-17T15:39:04Z",
    "endDate": "1848-11-17T15:50:19Z",
    "roleName": "temperature sensor"
  },
  "object": "nautilus-collection-item:00515643",
  "result": {
    "@type": "Dataset",
    "identifier": "nautilus-3D-scan:02545642",
    "name": "3D Scane of Nautilus Collection Item 00515643"
  },
  "startTime": "1848-11-17T15:39:04Z",
  "endTime": "1848-11-17T15:50:19Z"
}
```

If one would like to be even more FAIR and machine-actionable, you could use a `DefinedTerm` from an ontology to further qualify the categories of instruments or occupations of people when the metadata was recorded. Here's an example using the Occupation Ontology from the OBO Foundry and Library to describe the occupation of Pierre Aronnax, and a term from a fictional ontology for the category of the instrument used:

```json
{
    "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Action",
    "@id": "https://nautilus.verne/identifiers/Action-00252231.json",
    "name": "3D scanning of nautilus-collection-item:00515643",
    "agent": {
        "@type": "Role",
        "agent": {
            "@type": "Person",
            "givenName": "Pierre",
            "familyName": "Aronnax",
            "honorificPrefix": "Professor",
            "hasOccupation": {
                "@type": "Occupation",
                "occupationalCategory": [
                    {
                        "@type": "CategoryCode",
                        "inDefinedTermSet": "http://purl.obolibrary.org/obo/occo.owl",
                        "termCode": "OCCO:19200000",
                        "url": "http://purl.obolibrary.org/obo/OCCO_19200000",
                        "name": "physical scientist"
                    },
                    {
                        "@type": "CategoryCode",
                        "inDefinedTermSet": "http://purl.obolibrary.org/obo/occo.owl",
                        "termCode": "OCCO:19100000",
                        "url": "http://purl.obolibrary.org/obo/OCCO_19100000",
                        "name": "life scientist"
                    }
                ]
            }
        },
        "startDate": "1848-01",
        "endDate": "1849-12",
        "roleName": "Nautilus guest scientist"
    },
    "identifier": "nautilus-scanning-event:02552891",
    "actionStatus": "CompletedActionStatus",
    "instrument": {
        "@type": "Role",
        "instrument": {
            "@type": "Product",
            "name": "Nautilus 3D scanning chamber",
            "category": {
                "@type": "DefinedTerm",
                "inDefinedTermSet": "http://nautilus.verne/ontologies/nautilusMachines.owl",
                "termCode": "NautilusOnt:2929260",
                "url": "http://purl.obolibrary.org/obo/NautilusOnt:2929260",
                "name": "Three-dimensional scanning apparatus"
            }
        },
        "startDate": "1848-11-17T15:39:04Z",
        "endDate": "1848-11-17T15:50:19Z",
        "roleName": "temperature sensor"
    },
    "object": "nautilus-collection-item:00515643",
    "result": {
        "@id": "https://nautilus.verne/identifiers/Dataset-015481461",
        "@type": "Dataset",
        "identifier": "nautilus-3D-scan:02545642",
        "name": "3D Scan of Nautilus Collection Item 00515643"
    },
    "startTime": "1848-11-17T15:39:04Z",
    "endTime": "1848-11-17T15:50:19Z"
}

```

# Claims - quality, assessments, and other declarations along a provenance chain

Often, people or other agents assert their opinions, evaluation results, or other claims about a Thing as it journeys through Actions. The schema.org Type `Claim` (which is a sub-Type of `CreativeWork`, just like `Dataset`) can be used to capture these, and also to associate multiple assertions from different sources/agents to a Thing. 

> [!NOTE]
> Like most `Thing`s in schema.org, the `Action` that created a `Claim` (like a quality control process) can - and probably should - be described in its own JSON-LD record. This would help show the provenance of the `Claim` itself, which is usually essential information to evaluate its validity or usefulness. Using `Action` properties like `actionProcess` (shown above), one can express or link to the methods and procedures that were used to arrive at the `Claim`.

## Claims

Let's look at an example of a claim regarding the quality of Dataset-015481461 (described above). This time, rather than repeating content, we'll use the `@id` keyword to point to JSON files hosted on a fictional server. Recall that if these resolve to a valid JSON-LD object or set of objects stored in a file, the `@id` reference would "expand" to match their content. 

```json

   {
        "@context": {
            "@vocab": "https://schema.org/"
        },
        "@type": "Claim",
        "@id": "https://nautilus.verne/identifiers/Claim-000000323.json",
        "identifier": "Claim-000000323",
        "url": "https://nautilus.verne/identifiers/Claim-000000323.txt",
        "abstract": "A quality control result of 'Excellent' resulted from the execution of standard operating procedure X4632 on Dataset-015481461",
        "appearance": {
            "@type": "AudioObject",
            "@id": "https://nautilus.verne/identifiers/voice-log-000220337.json",
            "name": "Quality control department audio log 000220337"
        },
        "about": {
            "@id": "https://nautilus.verne/identifiers/Dataset-015481461.json"
        },
        "author": {
            "@id": "https://nautilus.verne/identifiers/Person-00000122.json"
        },
        "additionalProperty": {
            "@type": "PropertyValue",
            "propertyId": "",
            "name":
            "value": 
        
        }
    }
```

Above, we added that a specific person made a claim about Dataset-015481461, and an abstract property indicates the summary of that claim. The full claim is available by following the `url` property. We also note that the claim appears in an audio recording taken by the quality control department of the Nautilus.

## Claim reviews

 `ClaimReview` `itemReviewed` `Claim`  


# Expanding schema.org with other semantic resources

## Using additionalTypes

As we've seen above in the "Embedding Actions within Events" section, one can multi-type a JSON-LD object. If (and only if) your chosen semantic context (in our case, schema.org) doesn't have a Type you need, or only offers a very general type, you can bring in an additional type from another semantic resource.

> [!WARNING]
> Be very careful when using external semantic resources as `@type`s. For example, if your JSON object is meant to represent a physical thing like a specific physical, particular instance of a sensor, you should probably not use a SKOS concept as a value of `@type`, as this would suggest you're actually talking about a description of meaning, rather than about a real-world entity. You can use an OWL Class (whose instances represent physical things, rather than concepts about those things, and which has more rigid/clear interpretations) from a more formal ontology like SOSA, like [SOSA:Sensor](http://www.w3.org/ns/sosa/).

Let's use this to express that a schema.org `Product` is also a SOSA `Sensor`


```
{
    "@context": {
        "@vocab": "https://schema.org/",
        "sosa": "http://www.w3.org/ns/sosa/"
    },
    "@type": [
        "Product",
        "sosa:Sensor"
    ],
    "name": "underway aether flucutation sensor"
}
    
```

One could do something similar, with a less direct / softer assertion of the second type (which may prevent errors in some software that is unable to handle semantic subtleties), using schema.org's `additionalProperty` property:


```
{
    "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Product",
    "additionalType": "http://www.w3.org/ns/sosa/Sensor",
 	"name": "underway aether flucutation sensor"
}

```


## Using additionalProperties for more complex provenance chains

The core chain and the decorations 

Add RO relations for process-centric causal semantics.

wasGeneratedBy, `output of` `input of` 

Each domain and discipline will have different requirements, but the general principle is that the metadata contextualising the provenance chain should allow understanding and reproducibility.


# Advanced provenance 

## Highly granular provenance 

### Variable-level provenance 
variableMeasured - individual variable-by-variable provenance 

### breaking up Datasets and other creative works


# Further examples

Above, we have some basic examples for observation, sample processing, and data generation. Below, we'll add some more basic examples for other common activities:

## Model / analytical output

With CreativeWork as source

## Data harvest

## Data processing
Including subsetting and reformatting / new semantic markup of data
The start of the isBasedOn chain

potentialAction

## Data validation

potentialAction

## Data Analysis


# Other things to think about

prov:invalidatedAtTime / wasInvalidatedBy
Other CDIF cases to capture
Experiment
Hypothesis
Sample (material and statistical samples)
Method
Configuration
Instrument
* use sosa for the additionalType and then something like NERC SKOS for keywords?

