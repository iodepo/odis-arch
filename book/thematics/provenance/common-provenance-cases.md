# What is provenance?

Fundamentally, the provenance of a thing tells you where that thing came from. 

For example, real [Parmesan cheese]([url](https://en.wikipedia.org/wiki/Parmesan)) is produced in one of the provinces of Parma, Reggio Emilia, Emilia-Romagna, and parts of Mantua. That _should_ be its provenance. Thanks to the protected designations of origin (PDO) regulations in the European Union, one knows the provenance of Parmesan and Parmigiano Reggiano produced/sold in countries subject to those rules (indicated on the packaging). However, outside that regulatory environment, your Parmesan cheese can be of different or unknown provenance, with implications for its quality, authenticity, etc. Handling provenance in digital systems isn't all that different.

For datasets, documents, software, products, or anything else described by the JSON-LD/schema.org records flowing through ODIS, it's vital to indicate the provenance of the the things described. Who authored the paper? What sample was used to generate a dataset? Who or what manufactured a product? 

In this section, we provide guidelines on 1) how to express the basic provenance of a thing and 2) how to add context to that basic provenance to increase reusability, reproducibility, and add value to a digital asset.

# Basic provenance chains

The most basic provenance chain is a very short one: it should tell you where some "Thing" you're interest in originally came from. For example:
* Dataset "T363" was generated by a Temp-O-Matic Sea Surface Temperature sensor.
* Book "Guide to sampling sea salps" was published by Salps & Salps Publishing House.
* Sensor "Temp-O-Matic Sea Surface Temperature" was manufactured by "O-Matic Inc".

A (very) minimal JSON-LD/schema.org representation of the Dataset example above would need a JSON record about the Dataset itself, and another JSON record about the Action that created it.

Here's the minimal JSON-LD/schema.org about the Dataset:

```json
{
    "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Dataset",
    "@id": "https://registry.org/permanentUrlToThisJsonDoc/T363.json",
    "name": "Dummy temperature dataset",
    "identifier": "T363"
}

```

And here's the JSON-LD/schema.org about the Action that created it:

```json
{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "CreateAction",
    "@id": "https://registry.org/permanentUrlToThisJsonDoc/Creation-of-T363.json",
    "name": "Temperature measurement M363",
    "identifier": "M363",
    "actionStatus": "CompletedActionStatus",
    "instrument": "Temp-O-Matic Sea Surface Temperature sensor",
    "object": "surface seawater",
     "result": {
        "@type": "Dataset",
        "@id": "https://registry.org/permanentUrlToThisJsonDoc/T363.json"
     }
}

```

> [!NOTE]
> An Action can have many results (~ outputs) and objects (~ inputs/things the action was performed on), and can be more or less precisely scoped (e.g. we could split the measurement action above into the physical measurement and the data generation). The choice of how "granular" to be depends on each application scenario and resources available, but generally more detail is helpful for later reusability.

These two JSON records express that a dataset called "Dummy temperature dataset" with identifier "T363" was created by some completed action (with identifier M363) using a "Temp-O-Matic Sea Surface Temperatur sensor" as an instrument on some seawater. The [result](https://schema.org/result) property in the Action links the Dataset to the Action. The `@id` JSON keyword saves us some typing, as it would expand to everything in the Dataset record (assuming both records are available on the Web). 

Let's try a minimal example for a book. We could, as we did for dataset, talk about the CreateAction for the document, but since we're talking about the publisher as the "origin" of the document, we can be more compact:

```json
{
    "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Book",
    "@id": "https://registry.org/permanentUrlToThisJsonDoc",
    "name": "Guide to sampling sea salps",
    "identifier": "ISBN-13:978-1-56619-909-4",
     "publisher": {
        "@type": "Organization",
        "name": "Salps & Salps Publishing House",
        "address": "Salp street 32, Salpsville 42622, Republic of Salpia"
        }
}
```

Let's try a minimal example for the sensor, in which we use the schema.org [Product](https://schema.org/Product) type (useful for all manufactured products). As before, we could include a CreateAction and use properties from Action, but we can be more compact using the [manufacturer](https://schema.org/manufacturer) property:

```json
{
    "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Product",
    "@id": "https://registry.org/permanentUrlToThisJsonDoc",
    "name": "Temp-O-Matic Sea Surface Temperature",
    "identifier": "978-1-56619-909-4",
     "manufacturer": {
        "@type": "Organization",
        "name": "O-Matic Inc",
        "address": "O-Matic alley 3-6, Matictown 4367, Duchy of O-Matica"
        }
}
```


These most basic chains are useful, **but are rarely sufficient**. Most people (or other agents) usually need more information to confidently understand how to approach and interact with the Thing you're interested in. A more useful basic provenance chain would include:
* Information about the event (planned or unplanned) that created the Thing you're interested in, or something that it was derived from, including:
  * Who or what was involved in the event
  * What actions were performed that impacted or influenced the Thing or its precursor(s)
  * How those actions impacted that Thing or its precursor(s)
* Information about any subsequent events that changed or influenced the Thing you're interested in or its precursor(s)
* Basic contextual information about those events and the Thing you're interested in or its precursor(s). This will vary from Thing to Thing. For example:
  * The weather or other key environmental conditions at the time of sampling
  * Any known sources of error or bias

In the next sections, we'll demonstrate how to go about the above, noting how this aligns with the well-known and widely used PROV model for provenance tracking.

# The PROV model

> [!NOTE]
> For developers and digital practitioners, a mapping between schema.org properties and Types to PROV terms is available in the [SSSOM](https://mapping-commons.github.io/sssom/) format, [here](https://github.com/iodepo/odis-arch/blob/master/resources/semantic-maps/schema-to-prov.sssom). 


The [PROV Model](https://dvcs.w3.org/hg/prov/raw-file/default/model/working-copy/prov-dm-issue-450.html) is a widely used model for encoding provenance information. We align the guidance here to this model as far as possible. At the time of writing, the 2013 specification of [PROV Model](http://www.w3.org/TR/2013/REC-prov-dm-20130430/) is the most current. A permalink to the latest version is available [here](http://www.w3.org/TR/prov-dm/).

> [!WARNING]
> If there are PROV-aligned semantics/properties that are not expressible in schema.org, then semantics/terms from the [PROV-O ontology](https://www.w3.org/TR/2013/REC-prov-o-20130430/) can be used. **However, this should be done only when absolutely necessary**, as this introduces another semantic context and can reduce interoperability (i.e. like speaking two languages in the same conversation unnecessarily).
>
> Many PROV properties/relations like wasRevisionOf can/should be expressed by dedicated Actions in schema.org (e.g. a Revision Action), where the action can be described fully rather than adding the PROV-O property as a less informative short-cut.

The central PROV terms (known as [Starting Point terms](https://www.w3.org/TR/2013/REC-prov-o-20130430/#description-starting-point-terms)) are summarised in this diagram:
<img width="1775" height="1067" alt="image" src="https://github.com/user-attachments/assets/84b520d7-3d82-4bf4-a1ef-862255d81be4" />

PROV also has a set of [Expanded Terms](https://www.w3.org/TR/2013/REC-prov-o-20130430/#description-expanded-terms), which are also quite expressible in schema.org:
<img width="1729" height="957" alt="image" src="https://github.com/user-attachments/assets/0069ebd3-febf-4f4a-a582-8adc3d2c7389" />

While other extensions exist, we'll be focusing on aligning our schema.org to these sets of terms. 
# Core JSON-LD/schema.org patterns for expressing provenance

As expressed in the Starting Point terms of PROV model, the core of a provenance chain comprise the things we're talking about (Entities), the things that happened to them (Activities), and who or what performed these Activities (Agents). 

The key schema.org Type to use is [Action](https://schema.org/Action), which maps tightly to PROV:Activity. As we see in the example below, we can use use an Action (or its sub-Types) to express the Starting Point PROV model:

```json
{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Action",
    "@id": "https://registry.org/permanentUrlToThisJsonDoc/Action-00252229.json",
    "name": "Collection of rare seashell by the Nautilus sampling array",
    "agent": {
        "@type":"Person",
        "familyName": "Dakkar",
        "alternateName": "Captain Nemo",
        "honorificPrefix": "Prince"
    },
    "identifier": "nautilus-sampling-event:00252229",
    "actionStatus": "CompletedActionStatus",
    "location": {
        "@type": "Place",
        "name": "Pollux Tablemount",
        "latitude": "25.75",
        "longitude": "147.8333"
    },
    "instrument": "Nautilus sampling array",
    "object": "Intact Fulton's cowrie (Cypraea fultoni) shell",
    "result": "nautilus-sample:00713668",
    "startTime": "1848-11-17T14:42:10Z",
    "endTime": "1848-11-17T14:46:13Z"
}

```

This minimal code expresses a schema:Action (prov:Activity) performed by a schema:agent (prov:Agent) which used (prov:used) the "Nautilus sampling array" to collect an intact Fulton's cowrie shell (schema:object) at a specific place (prov:atLocation/Location) and time (prov:generatedAtTime), with a schema:result of a sample in the Nautilus extensive collection (i.e. the result prov:wasGeneratedBy the Action). The start and end time of the action are also recorded.

> [!NOTE]
> Naturally, one can and should use schema.org Types as values for each property (like `instrument`, `object` and `result`) to add more metadata or link to full records of these entities. The examples here are very terse.

Next, let's add another action to describe processing that sampled seashell for archiving in the Nautilus' specimen collection:

```json
{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Action",
    "@id": "https://registry.org/permanentUrlToThisJsonDoc/Action-00252230.json",
    "name": "Incorporation of Nautilus Sample 00713668 into the Nautilus Specimen Archive",
    "agent": {
        "@type":"Person",
        "familyName": "Dakkar",
        "alternateName": "Captain Nemo",
        "honorificPrefix": "Prince"
    },
    "participant": {
        "@type":"Person",
        "givenName": "Pierre",
        "familyName": "Aronnax",
        "honorificPrefix": "Professor"
    },
    "identifier": "nautilus-archiving-event:00592754",
    "actionStatus": "CompletedActionStatus",
    "instrument": [
        "sonication cleaning bath",
        "sealant vapour deposition chamber",
        "Nautilus thinking machine"
    ],
    "object": "nautilus-sample:00713668",
    "result": "nautilus-collection-item:00515643",
    "startTime": "1848-11-17T14:42:10Z",
    "endTime": "1848-11-17T14:46:13Z"
}

```

> [!IMPORTANT]
> Pay close attention to the way that the results and objects of an Action build a provenance chain: In the example above, we treat the output (result) of the previous Action as the input (object) of the next Action - this is how we connect the links of a provenance chain. Unambiguous identifiers for each element described and persistent URLs for each JSON-LD file are extremely valuable in making this chain unambiguous.

The JSON-LD/schema.org example above expresses that Captain Nemo, with the help of Professor Aronnax, used a sonication cleaning bath, a sealant vapour deposition chamber, and the Nautilus' computer to take the sample acquired in the previous Action, and archive it in the Nautilus' collection. 

The examples above describe the provenance of physical objects. Let's create another Action to express how a Dataset was created from the entity, once it was sampled. As above, we'll use the `object` and `result` properties to connect Actions to each other, as well as their inputs and outputs:

```json
{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Action",
    "@id": "https://registry.org/permanentUrlToThisJsonDoc/Action-00252231.json",
    "name": "3D scanning of nautilus-collection-item:00515643",
    "agent": {
        "@type":"Person",
        "givenName": "Pierre",
        "familyName": "Aronnax",
        "honorificPrefix": "Professor"
    },
    "identifier": "nautilus-scanning-event:02552891",
    "actionStatus": "CompletedActionStatus",
    "instrument": "Nautilus 3D scanning chamber",
    "object": "nautilus-collection-item:00515643",
    "result": {
        "@type": "Dataset",
        "identifier": "nautilus-3D-scan:02545642",
        "name": "3D Scan of Nautilus Collection Item 00515643",
        "about": "nautilus-collection-item:00515643"
    },
    "startTime": "1848-11-17T15:39:04Z",
    "endTime": "1848-11-17T15:50:19Z"
}

```

This record states (among other things) that 3D Scanning Action was performed upon the Collection Item generated in the previous Action. The result of that Action is a Dataset with a unique and persistent identifier, which is about the Collection Item. As we saw in the first set of examples, one can have a separate JSON record for the Dataset, rather than embedding it in an Action record. In that case, it would need an `@id` to identify it such that it can be found and correctly placed as the value of `result`.  

## Breaking down the Actions with HowTos

Ideally, a provenance record wouldn't just note that an Action occurred, but also how it occurred (i.e. what exact steps were taken to perform that Action). This information is very valuable for reproducibility and clear understanding of how things like datasets or samples came to be in the state they are.

The schema:`Action` Type offers a property called `actionProcess` where one can add a `HowTo` Type to log the steps taken to perform an Action. As with any Type, one can host these `HowTo`s and even their `HowToStep`s as stand-alone records with their own identifiers and `@id` values, to make reuse easier. To keep things more readable here, we'll skip this step. 

Let's examine a case expanding the 3D-scanning Action, above. Look for the `actionProcess` value, and :

> [!NOTE]
> Arrays in JSON - like the array of steps below - preserve their order, and the position of an object in an array is its position in that order.

```json
{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Action",
    "@id": "https://registry.org/permanentUrlToThisJsonDoc/Action-00252231.json",
    "name": "3D scanning of nautilus-collection-item:00515643",
    "agent": {
        "@type":"Person",
        "givenName": "Pierre",
        "familyName": "Aronnax",
        "honorificPrefix": "Professor"
    },
    "identifier": "nautilus-scanning-event:02552891",
    "actionStatus": "CompletedActionStatus",
    "instrument": "Nautilus 3D scanning chamber",
    "object": "nautilus-collection-item:00515643",
    "result": {
        "@type": "Dataset",
        "identifier": "nautilus-3D-scan:02545642",
        "name": "3D Scan of Nautilus Collection Item 00515643",
        "about": "nautilus-collection-item:00515643"
    },
    "startTime": "1848-11-17T15:39:04Z",
    "endTime": "1848-11-17T15:50:19Z",
    "actionProcess": {
        "@type": "HowTo",
        "name": "How to 3D scan a seashell with the Nautilus 3D scanning chamber",
        "estimatedCost": "20 Pounds Sterling and 40 shillings",
        "performTime": "T2H30M",
        "prepTime": "T30M",
        "supply": [
            "ambergris",
            "blank Amethyst data slate"
        ],
        "tool": [
            "asbestos gloves",
            "kelp-leather apron",
            "topaz protective goggles",
            "soda-lime gas mask"
        ],
        "yield": "Amethyst data slate with 3D scan data",
        "step": [
            {
                "@type": "HowToStep",
                "name": "Initialisation of the Nautilus 3D scanning chamber",
                "description": "Add three grains of ambergris to the device's brass thurible"
            },
             {
                "@type": "HowToStep",
                "name": "Sample loading",
                "description": "Place the object to be scanned in the copper casket ornamented with krakens at the centre of the chamber"
            },
            {
                "@type": "HowToStep",
                "name": "Configuration of the scanning process",
                "description": "Approach the luminous display panel bordered by red coral. Speak clearly and deferentially to explain how the scanning should proceed. The Nautilus difference engine will configure the chamber to account for your preferences. Should there be uncertainties, the difference engine shall ask you for further clarification."
            },
            {
                "@type": "HowToStep",
                "name": "Shelter or depart",
                "description": "Shelter behind at least 4 inches of cinnabar-coated lead during the operation of the machine. Alternatively, leave the scanning laboratory entirely - the scanning requires no supervision."
            },
            {
                "@type": "HowToStep",
                "name": "Scanning",
                "description": "The chamber will scan the sample by eldritch means. Scanning is complete when the copper casket ornamented with Krakens opens."
            },
                        {
                "@type": "HowToStep",
                "name": "Sample retrieval",
                "description": "Retrieve the sample from the copper casket ornamented with Krakens opens. Return to secure archiving or storage as needed."
            },
            {
                "@type": "HowToStep",
                "name": "Data slate retrieval",
                "description": "Approach the alcove ornamented with hippocampi in rampant pose. An amethyst data slate will emerge. Wait for it to cool and retrieve it. Your 3D scan is examinable with the Nautilus holographicum."
            }
            
        ]
    }
}
```


## Where to start and end a provenance chain

### Starting a provenance chain
A common concern is where to _start_ a provenance chain. There's no hard and fast answer to this, but - generally - one would start the main provenance chain where the first intentional action was taken by an agent upon some entity/Thing that either is the Thing one is interested in, or was an important precursor of that Thing.

In the examples above, let's say our main entity of interest was the Dataset (nautilus-3D-scan:02545642). Capturing the sampling action and the archiving actions that preceded the scanning action would be very helpful in understanding where the 3D scan dataset came from and what the data is about, along with providing information to explain any bias/errors such as artifacts introduced by the sealing and cleaning instruments used during archiving. Thus, the provenance chain of the dataset would start with the sampling of the shell the dataset is about.

Events or processes that _preceded_ the first intentional event are also important to contextualise the intentional actions along a provenance chain. Adding a few of these to a provenance chain can be very important to help communicate _why_ the first intentional action was taken in the first place. For more on this, see the section, below, on "Enriching a provenance chain with context".

### Ending a provenance chain

potentialAction (also Actions that have the appropriate `actionStatus` and link back to the Thing you're interested in in the `object` property.

## Events 

### Representing an event

Sometimes, unplanned processes that don't or may not have an agent (i.e. sometihng with agency, will, or volition) can affect the provenance of a prov:Entity or schema:Thing. For example, consider the impact of a natural or unplanned event like a cyclone or tsunami, equipment malfunctioning, or the degradation of a sample over time.

To help express these, schema.org offers an [Event](https://schema.org/Event) Type. Despite its original purpose to describe things like rock concerts or art exhibitions, this type can be used along a chain of Actions to record important occurrences that influenced the Thing you're interested in. Let's set up a basic example to describe an Event that made Captain Nemo decide to sample that seashell:

```json
{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Event",
    "@id": "https://registry.org/permanentUrlToThisJsonDoc/Event-01259994.json",
    "name": "Mass gathering and die off of Cypraea fultoni population",
    "identifier": "ecosystem-event:02265544332",
    "location": {
        "@type": "Place",
        "name": "Pollux Tablemount",
        "latitude": "25.75",
        "longitude": "147.8333"
    },
    "startDate": "1848-09-17",
    "endDate": "1848-18-17"
}
```

Note that the start date and end date of this Event contain the sampling event, and the location of the die off and the sampling event are the same. This allows matching these records with a spatial or temporal query, and the contextualisation of the Action with the Event.

One could be even more explicit, using a "sub-Event" and the `recordedIn` property to state that the 3D scan dataset records a part of this Event where the biomass of an individual Cypraea fultoni organism was deposited on the seafloor:

```json
{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Event",
    "@id": "https://registry.org/permanentUrlToThisJsonDoc/Event-01259994.json",
    "name": "Mass gathering and die off of Cypraea fultoni population",
    "identifier": "ecosystem-event:02265544332",
    "location": {
        "@type": "Place",
        "name": "Pollux Tablemount",
        "latitude": "25.75",
        "longitude": "147.8333"
    },
    "startDate": "1848-09-17",
    "endDate": "1848-18-17",
    "subEvent": {
        "@type": "Event",
        "@id": "https://registry.org/permanentUrlToThisJsonDoc/Event-01259998.json",
        "name": "Posthumous deposition of biomass of Cypraea fultoni individual obtained as nautilus-sample:00713668",
        "identifier": "ecosystem-event:02265544345",
        "recordedIn": "nautilus-3D-scan:02545642"
    }
}
```

This rendition links the identifiers of the dataset to the Events more explicitly, using `recordedIn` to link the dataset to the event, strengthening the links between these records with unambiguous context. That being said, the `recordedIn` property is quite "fuzzy", and doesn't precisely describe the relationship of most datasets

Unfortunately, schema.org doesn't seem to have a compact way of linking Actions to Events (e.g. like an "embeddedIn" or a process equivalent of "partOf"). Please see the "Using additional properties" section, below, for some possible approaches.

### Embedding Actions within Events

There's a clever way to embed an Action in an Event (i.e. that an Action occurred within an Event) by double-typing an object under `subEvent`. By multi-typing a JSON-LD object, one can use properties from both types. See an example below:

> [!WARNING]
> When multi-typing an object, **it's important that the Types used makes sense together.** Events and Actions are compatible (conceptually, an Event can also be an Action), but one wouldn't type something as both an Action and a Person, or a Vehicle and a Project.
> 
> **Please don't add a Type to an object just because it allows you to use a property from another Type that you think is convenient.** The types **must** make sense together.

```json
{
   "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Event",
    "@id": "https://registry.org/permanentUrlToThisJsonDoc/Event-01259994.json",
    "name": "Mass gathering and die off of Cypraea fultoni population",
    "identifier": "ecosystem-event:02265544332",
    "location": {
        "@type": "Place",
        "name": "Pollux Tablemount",
        "latitude": "25.75",
        "longitude": "147.8333"
    },
    "startDate": "1848-09-17",
    "endDate": "1848-18-17",
    "subEvent": {
        "@type": ["Event", "Action"],
    "@id": "https://registry.org/permanentUrlToThisJsonDoc/Action-00252229.json",
    "name": "Collection of rare seashell by the Nautilus sampling array",
    "agent": {
        "@type":"Person",
        "familyName": "Dakkar",
        "alternateName": "Captain Nemo",
        "honorificPrefix": "Prince"
    },
    "identifier": "nautilus-sampling-event:00252229",
    "actionStatus": "CompletedActionStatus"
    }
}
```


# Enriching a provenance chain with context

The basic provenance chains we've seen provide the core "trace" of a Thing's provenance. Naturally, there's a lot more information that most people would like about the links in that chain. 

We've already "decorated" the provenance chains described above with more information (e.g. information on agents), but there's likely much more to say. Below, we'll provide some general suggestions on how to enrich your provenance chain.



## Filling out properties

The easiest way to add rich context to a provenance chain in schema.org is simply to fill in as many properties on the Types you use. Ideally, those properties will be filled in by dedicated objects (i.e. Types, like `@Person` above) rather than just text, so more structured metadata is available to improve discovery, description, and (re)use.

For example:

```json
  "agent": {
        "@type":"Person",
        "familyName": "Dakkar",
        "alternateName": "Captain Nemo",
        "honorificPrefix": "Prince"
    }
```

is much better than:


```json
  "agent": "Captain Nemo"
```


## Adding Roles

Often, one would want to explicitly declare the roles of things like agents, especially if there are many participating in an Action. The Schema.org [Role](https://schema.org/Role) Type allows us to express roles within properties like `agent`:

```json

{
  "@context": {
    "@vocab": "https://schema.org/"
  },
  "@type": "Action",
  "@id": "https://registry.org/permanentUrlToThisJsonDoc/Action-00252231.json",
  "name": "3D scanning of nautilus-collection-item:00515643",
  "agent": {
    "@type": "Role",
    "agent": {
      "@type": "Person",
      "givenName": "Pierre",
      "familyName": "Aronnax",
      "honorificPrefix": "Professor"
    },
    "startDate": "1848-01",
    "endDate": "1849-12",
    "roleName": "Nautilus guest scientist"
  },
  "identifier": "nautilus-scanning-event:02552891",
  "actionStatus": "CompletedActionStatus",
  "instrument": {
    "@type": "Role",
    "instrument": {
      "@type": "Product",
      "name": "Nautilus 3D scanning chamber"
    },
    "startDate": "1848-11-17T15:39:04Z",
    "endDate": "1848-11-17T15:50:19Z",
    "roleName": "temperature sensor"
  },
  "object": "nautilus-collection-item:00515643",
  "result": {
    "@type": "Dataset",
    "identifier": "nautilus-3D-scan:02545642",
    "name": "3D Scane of Nautilus Collection Item 00515643"
  },
  "startTime": "1848-11-17T15:39:04Z",
  "endTime": "1848-11-17T15:50:19Z"
}
```

If one would like to be even more FAIR and machine-actionable, you could use a `DefinedTerm` from an ontology to further qualify the categories of instruments or occupations of people when the metadata was recorded. Here's an example using the Occupation Ontology from the OBO Foundry and Library to describe the job title of Pierre Aronnax, and a term from a fictional ontology for the category of the instrument used:

```json
{
    "@context": {
        "@vocab": "https://schema.org/"
    },
    "@type": "Action",
    "@id": "https://registry.org/permanentUrlToThisJsonDoc/Action-00252231.json",
    "name": "3D scanning of nautilus-collection-item:00515643",
    "agent": {
        "@type": "Role",
        "agent": {
            "@type": "Person",
            "givenName": "Pierre",
            "familyName": "Aronnax",
            "honorificPrefix": "Professor",
            "jobTitle": [
                {
                    "@type": "DefinedTerm",
                    "inDefinedTermSet": "http://purl.obolibrary.org/obo/occo.owl",
                    "termCode": "OCCO:19200000",
                    "url": "http://purl.obolibrary.org/obo/OCCO_19200000",
                    "name": "physical scientist"
                },
                {
                    "@type": "DefinedTerm",
                    "inDefinedTermSet": "http://purl.obolibrary.org/obo/occo.owl",
                    "termCode": "OCCO:19100000",
                    "url": "http://purl.obolibrary.org/obo/OCCO_19100000",
                    "name": "life scientist"
                }
            ]
        },
        "startDate": "1848-01",
        "endDate": "1849-12",
        "roleName": "Nautilus guest scientist"
    },
    "identifier": "nautilus-scanning-event:02552891",
    "actionStatus": "CompletedActionStatus",
    "instrument": {
        "@type": "Role",
        "instrument": {
            "@type": "Product",
            "name": "Nautilus 3D scanning chamber",
            "category": {
                "@type": "DefinedTerm",
                "inDefinedTermSet": "http://nautilus-ontologies.org/nautilusMachines.owl",
                "termCode": "NautilusOnt:2929260",
                "url": "http://purl.obolibrary.org/obo/NautilusOnt:2929260",
                "name": "Three-dimensional scanning apparatus"
            }
        },
        "startDate": "1848-11-17T15:39:04Z",
        "endDate": "1848-11-17T15:50:19Z",
        "roleName": "temperature sensor"
    },
    "object": "nautilus-collection-item:00515643",
    "result": {
        "@type": "Dataset",
        "identifier": "nautilus-3D-scan:02545642",
        "name": "3D Scan of Nautilus Collection Item 00515643"
    },
    "startTime": "1848-11-17T15:39:04Z",
    "endTime": "1848-11-17T15:50:19Z"
}

```

## Using additionalTypes

As we've seen above, 

For Actions, Events, Observation, Sampling

should be valid for an rdf:Type, like an owl:Class but not a skos:Concept


## Using additionalProperties

The core chain and the decorations 

Add RO relations for process-centric causal semantics.

wasGeneratedBy, `output of` `input of` 

Each domain and discipline will have different requirements, but the general principle is that the metadata contextualising the provenance chain should allow understanding and reproducibility.


# Adapting Actions 

Both material and statistical samples, including statistical sampling from an existing dataset as well as the creation of a sample dataset from measuring material things

## Sample processing / analysis

## Observation

## Model / analytical output

With CreativeWork as source

## Data production

The start of the isBasedOn chain

## Data harvest

## Data processing
Including subsetting and reformatting / new semantic markup of data

potentialAction

## Data validation

potentialAction

## Data Analysis


## Claims / assertions

prov:invalidatedAtTime / wasInvalidatedBy


## Quality and quality control
of data or other assets

Adding quality control actions and their outcomes as Claims 

# Advanced provenance 

## Highly granular provenance 

### Variable-level provenance 
variableMeasured - individual variable-by-variable provenance 

### breaking up Datasets and other creative works

Other CDIF cases to capture
Experiment
Hypothesis
Sample (material and statistical samples)
Method
Configuration
Instrument
* use sosa for the additionalType and then something like NERC SKOS for keywords?

```json
{
     "@context": {
        "@vocab": "https://schema.org/"
 },
            "@type": "Product",
            "@id": "https://urlToThisJson.org/sea-bird-SBE.json/",
            "name": "SeaTemp 5000 Sensor",
            "description": "High precision sea surface temperature sensor.",
            "manufacturer": {
              "@type": "Organization",
              "name": "SensorCorp"
            },
        "model": {
            "@type": "ProductModel",
            "identifier": "http://vocab.nerc.ac.uk/collection/L22/current/TOOL0022/",
            "name": "Sea-Bird SBE 37 MicroCat IM-CT with optional pressure (submersible) CTD sensor series"
        },
            "serialNumber": "SN-998877",
            "additionalProperty": [
              {
                "@type": "PropertyValue",
                "name": "accuracy",
                "value": "+/- 0.01 K"
              },
              {
                "@type": "PropertyValue",
                "name": "precision",
                "value": "0.005 K"
              }
            ]
            }
```

 
