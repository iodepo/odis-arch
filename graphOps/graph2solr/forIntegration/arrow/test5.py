import pyarrow as pa
import pyarrow.compute as pc

# Define the input table
table = pa.table([
    pa.array(["a", "a", "b", "b", "b", "c", "d", "d", "e", "c"]),
    pa.array(["a1", "a2", "b1", "b2", "b3", "c1", "d1", "d2", "e1", "c2"]),
], names=["keys", "values"])

# Disable multithreading globally
pa.set_cpu_count(1)

# Filter for key 'b' and get the first value
b_mask = pc.equal(table["keys"], "b")  # Create a boolean mask for filtering 'b'
b_table = table.filter(b_mask).group_by("keys").aggregate([
    ("values", "first")  # Ordered aggregator
])

print("----- b_table schema:")

print(b_table.schema)
print("----------------")

# Wrap the 'values' column in b_table into a list
# Use the correct column name generated by the aggregation

b_values_as_list = pa.array(
    [[value] for value in b_table.column('values_first')], type=pa.list_(pa.string())
)

# b_values_as_list = pa.array(
#     [[value.as_py()] for value in b_table.column('values_first')],
#     type=pa.list_(pa.string())
# )

print("----- b_values_as_list schema:")

# print(b_values_as_list.schema)
print("----------------")

# Re-enable multithreading by resetting the CPU count
pa.set_cpu_count(6)  # Resets to the default (number of CPUs)

# Filter for other keys and get lists
not_b_mask = pc.invert(b_mask)  # Create a boolean mask for excluding 'b'
other_table = table.filter(not_b_mask).group_by("keys").aggregate([
    ("values", "list")  # Aggregator that works with multiple threads
])

print("----- other_table schema:")

print(other_table.schema)
print("----------------")

# Combine the results into a single table
b_values_as_table = pa.Table.from_arrays([b_values_as_list], names=["keys", "values_first"])
result = pa.concat_tables([b_values_as_table, other_table])

# result = pa.concat_tables([b_values_as_list, other_table])

print(result)
